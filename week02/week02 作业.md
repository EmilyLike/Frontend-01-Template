# week02 作业

##  写一个正则表达式 匹配所有 Number 直接量 

**知识点：**

1. Number直接量是什么

   参考链接： https://blog.csdn.net/bannychen/article/details/51794621 

   Number直接量包括：

   - 整型直接量，包括正整数和负整数
   - 八进制，数字前加“0”，每个数字0-7。
   - 十六进制 ，数字前加“0x”，每个数字0-f。
   - 浮点型直接量

2. 正则表达式匹配

   正则表达式相关语法： https://juejin.im/post/5dab30c26fb9a04de818face 

**实现步骤：**

1. 定义字符串

2. 定义正则规则

   1. 整型直接量，包括正整数和负整数 和浮点数

      ```
      "^\\d+$"　　//非负整数（正整数 + 0）
      "^[0-9]*[1-9][0-9]*$"　　//正整数
      "^((-\\d+)|(0+))$"　　//非正整数（负整数 + 0）
      "^-[0-9]*[1-9][0-9]*$"　　//负整数
      "^-?\\d+$"　　　　//整数
      "^\\d+(\\.\\d+)?$"　　//非负浮点数（正浮点数 + 0）
      "^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数
      "^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$"　　//非正浮点数（负浮点数 + 0）
      "^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数
      "^(-?\d+)(\.\d+)?$"　　//浮点数
      ```

   2. 二进制

      ```
      ^0[bB][01]+$
      ```

      

   3. 八进制，数字前加“0”，每个数字0-7

      ```
      ^0[oO][0-7]+$
      ```

      

   4. 十六进制 ，数字前加“0x”，每个数字0-f

      ```
      ^0[xX][0-9a-fA-F]+$
      ```

   5. 整体

      ```
      ^-?\d+$|^(-?\d+)(\.\d+)?$|^0[bB][01]+$|^0[oO][0-7]+$|^0[xX][0-9a-fA-F]+$
      //Number
      var reg = /^-?\d+$|^(-?\d+)(\.\d+)?$|^0[bB][01]+$|^0[oO][0-7]+$|^0[xX][0-9a-fA-F]+$/g;
      ```

      

##  写一个 UTF-8 Encoding 的函数

**知识点**：

1. UTF-8介绍   http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html 
2. unicode介绍 https://www.ruanyifeng.com/blog/2014/12/unicode.html 
3. 补码

**解决方法**

1. 将字符串转成unicode，再转成utf8。

   参考链接： https://blog.csdn.net/weixin_33825683/article/details/89373233 

```javascript
function UTF8_Encoding(text) {
  // return new  Buffer();
   for (var i = 0; i < text.length; i++) {
        var code = text.charCodeAt(i);
       	var back = [];
        if (0x00 <= code && code <= 0x7f) {
                back.push(code);
        } else if (0x80 <= code && code <= 0x7ff) {
                back.push((192 | (31 & (code >> 6))));
                back.push((128 | (63 & code)))
        } else if ((0x800 <= code && code <= 0xd7ff) 
                  || (0xe000 <= code && code <= 0xffff)) {
                back.push((224 | (15 & (code >> 12))));
                back.push((128 | (63 & (code >> 6))));
                back.push((128 | (63 & code)))
        }
       for (i = 0; i < back.length; i++) {
            back[i] = (back[i]&0xff).toString(16);
       }
    return back;
  //将字符转化为unicode
  
  //unicode转化为UTF-8
   }
 
}
UTF8_Encoding('中')
```

2. encodeURI 和 encodeURIComponent  

   参考链接：

   [encodeURIComponent在MDN上的解释]( https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent )

   相关代码： https://blog.csdn.net/swimming_in_IT_/article/details/81117514 

   缺点：encodeURIComponent只能在转义中文字符。


##  写一个正则表达式，匹配所有的字符串直接量，单引号和双引号 

**知识点：**

1. 字符串直接量

2. 匹配单引号、双引号

   参考链接： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String 

   ```
   [\u0021-\u007E]{6,16}|[\x21-\x7E]{6,16}|(['"])(?:(?!\1).)*?\1
   //字符串
   var str5 = "Hello. I\'m liuyaxin,my email is \"1294343193@qq.com\".$￥####";
   var reg = /[\u0021-\u007E]{6,16}|[\x21-\x7E]{6,16}|(['"])(?:(?!\1).)*?\1/g;
   console.log(reg.test(str5));
   ```

   

##  完成一篇本周的学习总结 

本周从作业来讲，主要是讲了正则表达式相关内容。

第一章，讲了很多编译原理相关的东西。文法的类型啊，BNF啊，等等。

笔记如下：

# 4.16 课程笔记

## 编程语言通识

练习： 尽可能寻找你知道的计算机语言，尝试把他们分类

## 图灵完备性

图灵机： 凡是可以计算的东西，都被称为图灵机。

是不是万物可计算？ 一个图灵机，并不能计算另一个图灵机。

如何定义图灵完备性？

通过goto实现     通过if 和while实现

这个链接说的比较好：

 https://www.zhihu.com/question/20115374 

## 文法

针对于各种编程语言。

我们目前所使用的大部分语言都是高级语言，高级语言指的是偏向于使人类理解。

但是，人类理解的语言，计算机无法执行。

所以需要在高级程序语言和计算机可以执行的语言架起一座桥梁，即：编译器。

既然，要把高级语言进行翻译，那么就要定义相应的**明确**规则来完成翻译。

即语言的形式：

中文是一种非形式化语言，也就是没有办法通过完整的规则进行定义。（不严谨）

还有就是形式化语言。形式化语言，可以通过文法来进行描述。

文法描述是，语言中的每个句子通过严格定义的**规则**进行构造，利用规则生成语言中合法的句子。

这里，我们将整个的文法定义为G，G为一个四元组。

 G=（N，∑，P，S），其中N是非终结符的有限集合，∑是终结符的有限集合，N和∑不相交。V=N∪∑，称为总词表。P是一组重写规则的有限集合。S∈N，称为句子符或初始符。 

非终结符指的是，可以根据P中的规则，可以实现终结符替代非终结符。

根据P的规则不同，可以分为以下几类文法：

0 型  无限制文法

P 的规则就是没有规则？

1型  上下文相关

2型 上下文无关

3型  正则文法

> 1型文法：又称为上下文有关文法，
>
> （1）：式子左边可以有多个字符，但必须有一个非终结符
> （2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符
> 2型文法：又称为上下文无关文法，
> （1）：式子左边只能有一个字符，而且必须是非终结符
> （2）：式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符
> 3型文法：又称为正规文法（正规文法又包括左线性文法和右线性文法）
> （1）：式子左边只能有一个字符，而且必须是非终结符
> （2）：式子右边最多有二个字符，而且如果有二个字符必须是一个终结符和一个非终结符
> 如果只有一个字符，那么必须是终结符
> （3）：式子右边的格式一定要一致，也就是说如果有一个是（终结符+非终结符）那么所有的式子都必须是（终结符+非终结符）或只有终结符
> 正规文法——左线性文法：
> （1）：必须是三型文法
> （2）：式子右边的产生是（非终结符+终结符）或终结符的格式
> 正规文法——右线型文法：
> （1）：必须是三型文法
> （2）：式子右边的产生式是（终结符+非终结符）或终结符的格式
>
> 0型文法：当然在判断文法时，肯定是先从3型开始，如果不是再看是不是2型，如果还不是再看是不是1型，如果1,2,3型都不是哪就是0型文法！
> ————————————————
> 版权声明：本文为CSDN博主「Cjsy_2011」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/Cjsy_2011/article/details/32412967

## 动态语言和静态语言

动态语言：

在用户的设备/在线服务器上

产品实际运行时

Runtime

静态：

在程序员的设备上

产品开发时

（最重要的是类型系统）

## 强类型与弱类型

**强类型**：无隐式转换

比如： java C#  python

**弱类型**： 有隐式转换

比如： c c++ php 

 ![preview](https://pic4.zhimg.com/b0aeb7ffd1667b9162e5329154d43777_r.jpg) 



> 轮子哥的解释也很妙啊！
>
> 强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double
>
> 弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double
>
> 静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。
>
> 动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。
>
> 弱类型、强类型、动态类型、静态类型语言的区别是什么？ - vczh的回答 - 知乎 https://www.zhihu.com/question/19918532/answer/21645395 

BNF

终结符： 只能在产生式右边产生；无法产生新的符号了

非终结符： 可以被扩展的符号。既可以出现在产生式右边，也可以产生在左边。

